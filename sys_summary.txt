COMPREHENSIVE SYSTEM ARCHITECTURE SUMMARY
=========================================

This document provides a thorough overview of the self-healing code generation agent system, detailing each major component, their interconnections, and how they work together to create an intelligent software development assistant.

## SYSTEM OVERVIEW

The project implements a multi-agent AI system designed to automate software development tasks through natural language instructions. It consists of several specialized agents orchestrated through an event-driven architecture, with a React frontend dashboard for monitoring and control.

### Core Architecture Principles:
- **Multi-Agent Design**: Specialized agents for different tasks (planning, coding, analysis)
- **Event-Driven Communication**: Asynchronous message passing between components
- **Context-Aware**: Uses RAG for codebase understanding
- **Task Graph Orchestration**: Hierarchical task management with dependencies
- **Real-time Monitoring**: WebSocket-based live updates to frontend

## MAJOR COMPONENTS

### 1. REQUEST PLANNER (src/request_planner/)
**Purpose**: Main orchestrator that converts natural language requests into actionable plans

**Key Files**:
- `planner.py`: Core planning logic with LLM and heuristic strategies
- `integrated_request_planner.py`: Full integration with task graph and agent mapping
- `models.py`: StepKind enum for task type mapping
- `context.py`: Codebase context retrieval
- `llm.py`: LLM integration with structured outputs

**How it Works**:
1. Receives natural language change requests
2. Creates Plan object with steps using base planner
3. Maps StepKind to agent types (TEST→test_agent, EDIT/ADD→coding_agent)
4. Creates hierarchical task graph with dependencies
5. Handles parallel vs serial task execution modes
6. Publishes task.assigned events for scheduler

**Task Type Mapping**:
- StepKind.TEST → "test_agent"
- StepKind.EDIT/ADD/REFACTOR → "coding_agent"
- StepKind.REVIEW → "reviewer"
- StepKind.REMOVE → "coding_agent"

**Connections**:
- Uses RAG service for context gathering
- Creates tasks in Enhanced Task Graph
- Publishes events to Event Bridge
- Integrates with Task Scheduler for execution

### 2. ARCHITECT AGENT (src/architect/)
**Purpose**: High-level system design and plan creation

**Key Files**:
- `architect.py`: Main architect with plan creation and event publishing
- `plan_format.py`: YAML plan formatting and parsing
- `enhanced_task_graph.py`: Hierarchical task organization
- `task_graph_manager.py`: Task context and community management
- `llm_tools.py`: Function calling interface for task operations

**How it Works**:
1. Receives project requirements from user/webhook
2. Uses LLM to create implementation plan in YAML format
3. Publishes PlanCreatedMessage to event bridge
4. Plan includes task breakdown with priorities and dependencies
5. Integrates with Analyzer for architecture understanding
6. Reserves symbols via Symbol Registry if available

**Plan Creation Flow**:
1. `create_implementation_plan()` generates YAML plan
2. `_publish_plan_event()` sends PlanCreatedMessage
3. Event contains plan_id, project_id, plan_content, task_count
4. Task Scheduler listens for plan.created events

**Connections**:
- Uses RAG for codebase understanding
- Publishes events through Event Bridge
- Integrates with Symbol Registry for symbol reservation
- Enhanced by Analyzer's architecture summaries

### 3. CODING AGENT (src/coding_agent/)
**Purpose**: Converts coding tasks into actual code changes and git commits

**Key Files**:
- `agent.py`: Main coding agent orchestrator
- `integrated_coding_agent.py`: Full integration with IntegratedAgentBase
- `context_gatherer.py`: Smart context retrieval
- `patch_generator.py`: LLM-based diff generation
- `file_rewriter.py`: Alternative full-file rewriting
- `validator.py`: Code validation pipeline

**How it Works**:
1. Inherits from IntegratedAgentBase for standard integration
2. Implements `on_task_assigned()` to handle task events
3. Reads implementation plans from plan storage
4. Searches RAG for similar implementations
5. Generates code changes based on task description
6. Updates task progress via event system
7. Stores successful implementations in RAG

**Integration Features**:
- Uses AgentContext for shared infrastructure
- Task progress updates via `update_task_progress()`
- Task completion via `complete_task()` or `fail_task()`
- Git workflow integration for branching/commits
- Session logging for audit trail

**Connections**:
- Extends IntegratedAgentBase for standard patterns
- Uses plan storage to read implementation details
- Reports progress via Event Integration
- Integrates with Git Workflow for atomic commits

### 4. ANALYZER AGENT (src/analyzer/)
**Purpose**: Automatic architecture analysis and documentation with dynamic summaries and flowcharts

**Key Files**:
- `analyzer.py`: Main analysis orchestrator
- `models.py`: Data structures for architecture representation (includes `to_mermaid()` method)

**Key Features**:
- **Dynamic Architecture Summaries**: Generates markdown summaries with insights, warnings, and recommendations
- **Mermaid Flowchart Generation**: Creates visual architecture diagrams showing components and dependencies
- **Pattern Detection**: Identifies MVC, Repository, Service Layer patterns
- **Technology Detection**: Recognizes frameworks (React, Flask, Spring, etc.)
- **Component Classification**: Services, Controllers, Models, Views, Repositories, Entry Points
- **Dependency Analysis**: Maps imports and relationships between components

**How it Works**:
1. Discovers components based on file patterns
2. Analyzes dependencies through imports (AST parsing for Python, regex for JS/TS/Java)
3. Detects architectural patterns and technologies
4. Generates `AnalysisReport` with insights
5. Creates Mermaid diagrams via `ArchitectureGraph.to_mermaid()`
6. Saves analysis to `.architecture/` directory
7. Can be triggered manually or by change thresholds

**Integration with Architect**:
- Architect now initializes Analyzer on startup
- Architecture summary and diagram are loaded into Architect's system prompt
- Provides `refresh_architecture_analysis()` method for on-demand updates
- Enriches Architect's understanding of the codebase structure

**Output Files**:
- `.architecture/ARCHITECTURE.md`: Markdown summary with insights
- `.architecture/architecture-diagram.mmd`: Mermaid diagram file
- `.architecture/architecture-report.json`: Full analysis report

**API Endpoints** (in minimal_webhook_server.py):
- `GET /api/analyzer/diagram`: Returns Mermaid diagram
- `POST /api/analyzer/refresh`: Forces analysis refresh
- `GET /api/analyzer/summary`: Returns markdown summary

**Connections**:
- Integrates with Change Tracker for automatic re-analysis
- Updates RAG with analysis results
- Provides data for frontend ArchitectureDiagram component
- Now integrated into Architect's system prompt for enhanced context

### 5. TEST AGENT (src/test_agent/)
**Purpose**: Intelligent test generation, execution, and adaptation

**Key Files**:
- `test_agent.py`: Test generation and planning logic
- `test_executor.py`: Test execution and failure analysis
- `integrated_test_agent.py`: Full system integration
- `models.py`: Test strategies and result structures

**Architecture**:
The Test Agent uses a two-component design:
1. **TestAgent**: Plans and generates tests using LLM
2. **TestExecutor**: Runs tests and filters/summarizes results

**Key Features**:
- **LLM-Based Test Generation**: Creates comprehensive tests with minimal mocks
- **Smart Failure Analysis**: Determines if failures are due to:
  - Test issues (assertions, syntax)
  - Code bugs
  - Missing dependencies
- **Adaptive Test Repair**: Fixes tests based on execution results
- **Concise Error Reporting**: Filters huge error logs to relevant information
- **Test Strategy Selection**: Unit, Integration, E2E, Property-based
- **Framework Detection**: Works with pytest and unittest

**How it Works**:
1. Receives test tasks from Request Planner (StepKind.TEST)
2. Analyzes target code to understand testing needs
3. Searches RAG for similar test patterns
4. Generates tests using LLM with minimal mocks
5. Executor runs tests in isolation
6. Analyzes failures and provides filtered summaries
7. Adapts failed tests if needed
8. Reports results to Architect with recommendations

**Event Flow**:
- `test.generated`: Tests created
- `test.executed`: Test run completed
- `test.failed`: Test failed with analysis
- `test.fixed`: Test repaired and passing
- `test.coverage`: Coverage metrics
- `test.report`: Summary sent to Architect

**Integration Benefits**:
- Clean separation of test tasks on message bus
- Specialized system prompts for test generation
- Intelligent error filtering reduces noise
- Feedback loop enables test improvement

**Connections**:
- Receives tasks from Request Planner
- Uses RAG to find test patterns
- Reports to Architect for planning
- Coordinates with Coding Agent for fixes

### 6. RAG SERVICE (src/rag_service/)
**Purpose**: Retrieval-Augmented Generation for codebase understanding

**Key Files**:
- `service.py`: Main RAG orchestrator
- `chunker.py`: Semantic code chunking
- `embeddings.py`: OpenAI embedding generation
- `vector_store.py`: ChromaDB vector storage
- `search.py`: Hybrid search implementation
- `client.py`: Simplified interface

**How it Works**:
1. Indexes codebase with semantic chunking
2. Generates embeddings for code chunks
3. Stores in vector database
4. Provides hybrid search (vector + keyword)
5. Formats results for LLM consumption
6. Supports incremental updates

**Connections**:
- Used by all agents for context
- Integrated with file system monitoring
- Provides search API for frontend

### 6. CORE INFRASTRUCTURE (src/core/)

#### Integration Framework:
- `integrated_agent_base.py`: Base class providing standard integration patterns
- `agent_integration_interfaces.py`: Integration interfaces (TaskGraph, RAG, Event)
- `agent_context.py`: Shared context for all integrated agents

#### Event System:
- `message_bus.py`: Internal pub/sub system for typed messages
- `event_bridge.py`: Bridges internal events to WebSocket streaming
- `simple_event_bridge.py`: String-based event wrapper for easy integration
- `realtime.py`: WebSocket server for frontend communication

#### Agent Coordination:
- `agent_registry.py`: Tracks agent states, capabilities, and health
- `task_scheduler.py`: Assigns tasks based on dependencies and agent availability
- `git_workflow.py`: Manages git branches and commits per task
- `plan_storage.py`: Stores and retrieves implementation plans

#### Monitoring:
- `session_logger.py`: Comprehensive logging of agent activities
- `flow_tracker.py`: Tracks message flows between agents
- `metrics_collector.py`: System resource monitoring
- `change_tracker.py`: File change monitoring

### 7. TASK GRAPH SYSTEM (src/architect/)
**Purpose**: Hierarchical task management with dependencies

**Key Files**:
- `enhanced_task_graph.py`: Core task graph implementation
- `task_graph_manager.py`: High-level task operations
- `community_detector.py`: Task clustering algorithm

**How it Works**:
1. Maintains hierarchical task structure
2. Tracks dependencies and states
3. Detects task communities/themes
4. Provides abstracted views for UI
5. Integrates with scheduler for execution

### 8. WEBHOOK SYSTEM (src/webhook/)
**Purpose**: External integration and API server

**Key Files**:
- `server.py`: FastAPI server with WebSocket
- `handlers.py`: Platform-specific handlers (Discord, GitHub, Slack)
- `security.py`: Authentication and rate limiting
- `executor.py`: Async task execution queue

**How it Works**:
1. Receives webhooks from external platforms
2. Validates security (tokens, signatures)
3. Parses platform-specific payloads
4. Creates and queues agent tasks
5. Provides REST API for frontend
6. Manages WebSocket connections

### 9. FRONTEND DASHBOARD (frontend/)
**Purpose**: React-based monitoring and control interface

**Key Components**:
- `BuildPage.tsx`: Main development interface
- `TaskGraph.tsx`: Interactive task visualization
- `ChangeMetrics.tsx`: Code change tracking
- `ArchitectureDiagram.tsx`: System visualization
- `api/client.ts`: Backend API client

**Features**:
- Real-time agent status monitoring
- Interactive task graph visualization
- Code change metrics
- Architecture diagrams
- Chat interface for Architect

## DATA FLOW

1. **Full Agent-to-Agent Pipeline**:
   User Request → Webhook/Frontend → Architect (creates plan) → PlanCreatedMessage → 
   Event Bridge → Task Scheduler → Request Planner (converts to tasks) → 
   Enhanced Task Graph → Agent Assignment → Task Execution → Results

2. **Plan-Based Execution Flow**:
   - Architect creates YAML plan with task breakdown
   - Publishes plan.created event with plan content
   - Task Scheduler receives event and triggers plan processing
   - Request Planner maps plan steps to agent types
   - Creates task graph with proper dependencies
   - Scheduler assigns tasks based on readiness

3. **Agent Integration Flow**:
   - All agents extend IntegratedAgentBase
   - Receive AgentContext with shared infrastructure
   - Handle task.assigned events via on_task_assigned()
   - Update progress via task integration
   - Publish completion via event integration

4. **Event Communication**:
   - Typed messages via Message Bus (internal)
   - Event Bridge converts to WebSocket events
   - Simple Event Bridge provides string-based interface
   - Agents subscribe/publish through event integration

5. **Task State Management**:
   - Tasks tracked in Enhanced Task Graph
   - Dependencies managed automatically
   - Status updates propagated via events
   - Progress tracked in Agent Registry

## KEY INTEGRATIONS

1. **Agent Integration Pattern**:
   - Base class: IntegratedAgentBase
   - Context: AgentContext with project path, event bridge, task manager, RAG client
   - Three integration levels: FULL, TASK_ONLY, RAG_ONLY
   - Standard methods: on_task_assigned(), update_task_progress(), complete_task()

2. **Task-Agent Mapping**:
   ```python
   StepKind.TEST → "test_agent"
   StepKind.EDIT/ADD/REFACTOR → "coding_agent"  
   StepKind.REVIEW → "reviewer"
   StepKind.REMOVE → "coding_agent"
   ```

3. **Event Message Types**:
   - PlanCreatedMessage: Plan content and metadata
   - TaskProgressMessage: Task updates
   - AgentStatusMessage: Agent state changes
   - CodeOperationMessage: Code changes

4. **Integration Adapters**:
   - TaskGraphIntegrationImpl: Task CRUD operations
   - RAGIntegrationImpl: Knowledge search and storage
   - EventIntegrationImpl: Event pub/sub

5. **Git Workflow Integration**:
   - Per-task branches
   - Atomic commits
   - Branch management by task group

6. **Session Logging**:
   - Comprehensive activity tracking
   - Task creation/completion
   - RAG queries
   - Code operations

## CONFIGURATION

- Environment variables for API keys and models
- YAML configuration files (.agent.yaml)
- Project mappings for webhook routing
- Configurable thresholds and limits

## DEPLOYMENT ARCHITECTURE

1. **Development Mode**:
   - Frontend: Vite dev server (port 5173)
   - Backend: FastAPI server (port 8088)
   - Services: In-process

2. **Production Mode**:
   - Frontend: Static build
   - Backend: ASGI server (uvicorn)
   - Services: Can be distributed

## KNOWN ISSUES AND LIMITATIONS

### Backend Agent Connection Issues:
1. **Missing WebSocket Implementation in Frontend**:
   - Frontend API client only uses REST endpoints
   - No real-time updates implemented in frontend components
   - WebSocket exists in backend but not connected

2. **Incomplete API Implementation**:
   - Main webhook server missing several endpoints
   - Separate minimal server implements missing endpoints
   - Inconsistency between servers

3. **Module Import Errors**:
   - `src.code_planner.integrated_code_planner` module missing
   - Causes integration demo failures

4. **Test Failures**:
   - E2E tests failing due to API mismatches
   - Parameter mismatches in agent initialization
   - Missing attributes in data models

5. **RAG Service Dependencies**:
   - Requires OpenAI API key
   - Falls back gracefully but limits functionality
   - Embedding generation can be costly

6. **Frontend Data**:
   - Some components use hardcoded demo data
   - Could be enhanced to use real API data

### Environment Issues:
1. **Configuration Complexity**:
   - Multiple configuration sources
   - Environment variables not always documented
   - Inconsistent defaults

2. **Development Setup**:
   - Complex dependency requirements
   - Multiple services to coordinate
   - Platform-specific issues (Windows/Linux/Mac)

3. **Resource Usage**:
   - Can be memory intensive with large codebases
   - Embedding generation requires significant compute
   - Multiple LLM calls can be expensive

## RECENT IMPROVEMENTS

1. **WebSocket Connection Fixed**: Frontend-backend WebSocket connection is now working
2. **Architect-Analyzer Integration**: Analyzer's dynamic summaries and flowcharts now integrated into Architect's system prompt
3. **Enhanced Architecture Understanding**: Architect now has built-in awareness of project structure through Analyzer
4. **Dedicated Test Agent**: New intelligent test agent with:
   - LLM-based test generation replacing hardcoded templates
   - Separate TestExecutor for clean error filtering
   - Adaptive test repair based on failure analysis
   - Proper task routing via StepKind.TEST mapping
5. **Task Type Mapping Fixed**: IntegratedRequestPlanner now correctly routes tasks based on StepKind

## RECOMMENDATIONS

1. **Unify API Servers**: Merge minimal and main webhook servers
2. **Complete Missing Modules**: Implement missing integrated agents (e.g., integrated_code_planner)
3. **Improve Test Coverage**: Run and fix E2E tests after recent changes
4. **Documentation**: Add setup guides and API documentation
5. **Error Handling**: Improve error messages and recovery
6. **Performance**: Add caching and optimize LLM usage
7. **Security**: Implement proper authentication for production
8. **Analyzer Enhancements**: 
   - Add support for more languages/frameworks
   - Implement incremental analysis for large codebases
   - Add custom pattern detection rules

## CONCLUSION

This system represents a sophisticated approach to AI-assisted software development, combining multiple specialized agents with modern web technologies. While the architecture is well-designed and modular, there are implementation gaps particularly in the frontend-backend integration that need addressing for production readiness. The event-driven architecture and task graph system provide excellent foundations for scaling and extending the system's capabilities.